#!/usr/bin/env python3

"""
Performs a 'linting' of an assembly file, ensuring that formatting errors do not make
it into the final output.
"""

import getopt
import os
import re
import sys

# The input file to be linted.
INPUT_FILE = None

# Whether to abort the linting process on encountering any error.
ABORT_ON_ERROR = False
# The maxmimum length of any line.
MAX_LENGTH_LINE = 80
# The maximum length of a label.
MAX_LENGTH_IDENTIFIER = 40
# The prefix for local labels.
LOCAL_LABEL_PREFIX = "."
# Whether to automatically fix fixable errors.
FIX_ERRORS = False


def lint_line(line):
    """
    Processes an individual line of source code, checking for formatting errors.
    """

    # Finds, and optionally fixes lines where the line separator stretches over the 80
    # character limit.
    REGEX_LINE_SEPARATOR = r"^; ={79,}"
    if re.match(REGEX_LINE_SEPARATOR, line):
        return (False, f"Line separator is too long", f"; {'=' * 78 }\n")

    # Check the length of a comment line.
    REGEX_LINE_COMMENT = r"^;.*"
    if re.match(REGEX_LINE_COMMENT, line):
        if len(line.rstrip()) > MAX_LENGTH_LINE:
            return (False, 'Comment line too long', None)

    # Check the total length of the line.
    if len(line.rstrip()) > MAX_LENGTH_LINE:
        return (False, "Line too long", None)

    # Check the maximum length of each label.
    REGEX_LABEL = r"([.\w?]+):"
    label_match = re.match(REGEX_LABEL, line)
    if label_match:
        if len(label_match.group(1)) > MAX_LENGTH_IDENTIFIER:
            return (False, f"Label '{label_match.group(1)}' too long", None)

    return (True, None, None)


def lint_file():
    """
    Lints the input file.
    """

    try:
        full_file_path = f"{os.getcwd()}/{INPUT_FILE}"

        with open(full_file_path, 'r') as input_file:
            # The current line number.
            line_number = 1
            # The total number of errors encountered.
            error_count = 0

            output_lines = []
            source_lines = input_file.readlines()
            for source_line in source_lines:
                (lint_result, lint_error, replacement) = lint_line(source_line)
                if lint_result:
                    output_lines.append(source_line)
                else:
                    if replacement and FIX_ERRORS:
                        print(f"Fixing line {line_number}", file=sys.stderr)
                        output_lines.append(replacement)
                    else:
                        print(f"Error: '{lint_error}' on line {line_number}", file=sys.stderr)
                        error_count = error_count + 1
                        output_lines.append(source_line)

                        if ABORT_ON_ERROR:
                            exit(1)

                line_number = line_number + 1

            print(f"Found {error_count} errors in total.")

        with open(INPUT_FILE, 'w') as input_file:
            input_file.writelines(output_lines)

    except FileNotFoundError:
        print("Error: Unable to open assembler files. Exiting.", file=sys.stderr)
        exit(1)


def print_usage():
    """Prints script usage to STDOUT."""

    print("Usage: lint_source --input_file <string>")


if __name__ == "__main__":
    try:
        OPTS, ARGS = getopt.getopt(
            sys.argv[1:],
            "h",
            [
                "input_file=",
                "help",
                "fix"
            ]
        )
    except getopt.GetoptError:
        print_usage()
        sys.exit(2)
    for opt, arg in OPTS:
        if opt == "-h" or opt == "--help":
            print_usage()
            sys.exit()
        elif opt == "--input_file":
            INPUT_FILE = arg
        elif opt == "--fix":
            FIX_ERRORS = True

    if INPUT_FILE is None:
        print("No input file provided! Exiting.")
        exit(1)

    lint_file()
